---
title: 计算机网络模型
categories:
  - - 计算机网络
tags:
  - 计算机网络
abbrlink: 44b77262
date: 2020-03-31 18:55:09
---

# 概述

技术的迭代离不开实际应用。计算机科学也是如此。这个思想在我学习计算机组成和计算机网络时给我了很大的启发。  在学习时，不妨从实际应用出发。从 ‘’提出问题→技术解决问题→发现新问题→使用新技术‘’ 的思想来学习。

每一种技术都是为了解决问题而诞生的，当理解了这些技术是如何结局问题后，就会对技术有更加深刻的理解。

---



# 计算机网络模型

现代计算机网络模型大概分为三种，主要的差异在于传输层之后的细化。当到达传输层后及计算机之间的通信已经建立了有效的连接，之后的细分主要是具体应用和进程之间的协调。理解了物理层，数据链路层，网络层，传输层后就能够对整个计算机模型有宏观的认识。

**计算机网络三种模型：**

![image-20200331185916221](https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200331185924.png)

- OSI分层      （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
- TCP/IP分层（4层）：网络接口层、              网际层、运输层、                            应用层。
- 五层协议     （5层）：物理层、数据链路层、网络层、运输层、                            应用层。

---



# 物理层

将终端（计算机）组成网络的最基础方式就是用线缆连接各个终端。通过电信号完成终端之间的通信。

**连接方式**： hub集线器。将终端两两连接的方式显然不可行，使用hub（集线器设备）将终端连接到一个端点，节省线材，容易实现。

**传递方式**：为了确保每个终端都能通信。由hub同时向所有连接的设备广播带有标识的数据包，设备接收对应的数据。

**CMSA/CD协议**：载波监听链路数据，确认有人在发送数据后，才开始发送数据，主要功能是解决数据冲突。

**数据包**：高低电平数据信息+设备标识。

**缺点**：

* 数据（广播）同时发送给所有设备，带宽利用率低。
* 链路上同时只能有一台设备发送数据。
* 随着网络规模扩大，发送信号需要等待很长时间。

**示例图**：

![image-20200330195443040](https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200330195445.png)

---



# 数据链路层

为了解决物理层带宽利用率低的问题，在网络中添加了交换机。能够保存每个mac终端的地址，定向发送数据。同时使用双工网线，可以同时发送和接收数据。

**连接方式**：交换机（switch）

**传递方式**：交换机与hub相似，都是作为集线器。但是交换机会记录端口和设备mac地址的对应关系。通过线路至准确的放数据，而不是广播。

**数据包**：包含数头和数部分。数据头记录了源地址和目的地址（mac地址）。

**mac地址**：网络设备的全球唯一标识，是在设备出厂时就已经写死的。有6段，每段8个bit，是一个48位的标识。

**地址表**：交换机会将端口和设备的mac地址对应关系记录在地址表中，当两台设备发生通信时，就可以找到对应的端口进行通信了。

**地址表的记录**：当有新的设备接入交换机时，会遍历所有的接口，直到找到对应的端口，然后储存在地址标准中，下一次发送就可以直接找到对应端口了。

**桥接**：多台交换机可以进行桥接，当一台交换机连接了另一台交换机后，会记录连接的端口和交换机的mac地址。

需要进行通信时，先传递数据到设备所在的交换机，再有交换机的地址表找到对对应的端口进行数据传输。



**优点**：

* 通过地址表直接进行设备间的通信传输，不需要广播，提高了带宽利用率。
* 全双工,交换机网络内，设备的连接使用的是网线，含有8跟导线，可以做到同时收发信息。
* 可以进行桥接，组成小型网络，利用率很高

**缺点**：

* 地址表能够保存的数据有限，一般一个地址表只能保存几千条，设备数量增多时利用率下降。

示例图：

![image-20200330195507598](https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200330195509.png)

---



# 网络层

交换机虽然能够桥接，但是在大型网络中还是无法胜任。因此使用路由器将一个个小型网络连接在一起，当两个小型网络间需要通信时，通过ip地址来连接。这样就组成了现在的互联网。

**连接方式**：网关（路由器）

**ip地址**：记录设备在网络中的位置。当设备接入网络时会分配给ip地址。这个ip地址是暂时的，当设备更换时会被重新分配。*	ip地址是不能通信的，是一个抽象的地址。

**路由表**：路由表会记录不同网络间ip对应的mac地址。

**arp协议**：根据ip地址查询mac地址。在网络中广播，寻问目的ip地址，目的ip地址收到后会回复自己的ip地址和mac地址。

**数据包**：数据头部分包含源地址的ip和目的地址的ip。

**传递方式**：网关负责连接由交换机组成的不同的网络，当两台通信设备在不同的网络中时，会通过路由器在两个网络间传递数据。

​	当不同网络下的设备需要通信时：

1. 数据传递过程中源地址ip和目的地址ip不变。

2. 因为数据传递只能通过mac地址进行，所以会逐步传输到链路上的各个网卡的mac地址，最终传到目的mac地址。

3. 通过arp协议或传输过程中的各个mac地址。

---



# 传输层

[网络层](https://baike.baidu.com/item/网络层)只是根据[网络地址](https://baike.baidu.com/item/网络地址)将源结点发出的[数据包](https://baike.baidu.com/item/数据包)传送到[目的](https://baike.baidu.com/item/目的)结点，而传输层则负责将数据可靠地传送到相应的端口。

* 分组：接收方的传输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。
* 复用：发送方不同的应用进程都可以使用同一个传输层协议传输数据。



**进程通信的问题，为什么不能直接从ip连接到进程：**

* 计算机中的进程使用进程标识来标志的，但是不同系统的进程标识方法不同。
* 进程的创建和撤销往往是动态的，有时候可能会更换进程但是不需要更换所接受的数据。
* 有时还需要目的主机提供的功能来识别重点，但是不需要知道实现这个功能的进程。



**端口**：IP地址只能标识到某台主机，但是数据最终要交付的是主机中的某个进程；一个主机中会有许多的进程，那么如何确定这个数据是要交付给哪个进程呢？此时就需要用到端口号。

于是在运输层使用协议端口号（protocolpport number），或者通常称为端口（port）。

端口使用一个16位的端口号进行标志。端口号只有本地意义，即端口号只是标识了本机中的各个进程。



**端口的分类：**

* 端口号的范围是从1～65535，一般分为3类端口：熟知端口号，登记端口号，客户端口号或短暂端口号。
* 熟知端口号，数值一般为0~1023，每个端口号应用于特定熟知的应用协议。
* 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在IANA(The Internet Assigned NumbersAuthority，互联网数字分配机构)登记，以防止重复。
* 客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。



**套接字（socket）**

tcp协议中将连接作为基本的单位，每一条tcp连接两个端，都是由  主机ip+进程端口拼接而成，称作套接字。

套接字（socker）= ip地址：端口号

tcp连接== {socket1, socket2} = {(IP1: port1), (IP2: port2)}



**udp协议：**

* UDP是一种无连接，不可靠的协议。
* 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。
* 此外，传输途中出现丢包，UDP 也不负责重发。甚至当包的到达顺序出现乱序时也没有纠正的功能。
* UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。

udp的头部：

![img](https://img-blog.csdnimg.cn/20181127124245824.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Njg0NTA0,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20181127124512100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Njg0NTA0,size_16,color_FFFFFF,t_70)



### **tcp协议：**tcp协议详细



**三次握手：**

三次握手解决了tcp连接的建立问题。

通过三次握手建立连接：假设 A 为客户端，B 为服务器端。

* 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

* 第一次握手`：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

* 第二次握手`：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

* 第三次握手`：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

> 第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销

![image-20200331190005051](https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200331190007.png)



**四次挥手：**

因为tcp连接是全双工的，所以发送和接收的端口都要单独关闭，四次挥手保证的了关闭连接的在正确性，保证了连接关闭时不会丢失数据。

* TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
* 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
* 服务器关闭客户端的连接，发送一个FIN给客户端。
* 客户段发回ACK报文确认，并将确认序号设置为收到序号加1。

![image-20200331190026589](https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200331190033.png)



**数据重传：**



**滑动窗口：**

滑动窗口是为了解决发送发送端和接收端对数据包的处理速度不同欧诺个，如何让双方达成一致。

TCP是双工的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方都各自维护一个`发送窗口`和一个`接收窗口`。各自的`接收窗口`大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的`发送窗口`则要求取决于对端通告的`接收窗口`，要求相同。

**TCP连接是通过数据包和ACK实现的，我们作为第三者可以看到双方发包的过程，但接受者在收到之前不知道发送方发的是什么，同样的，发送方在收到ACK前也不知道对方是否成功接收。**

1. 发送方没有收到接收方发回的ACK，就不能向右滑动。假设发送方向接收方发了ABCD就滑动，只要对方没收到A，就不能滑动，那么就会出现二者不同步的局面。
2. 滑动窗口提高了信道利用率，TCP是发送报文段为单位的，假如每发一个报文就要等ACK，那么对于大数据包，等待时间就太长了。只要发送的报文在滑动窗口里面，不用等每个ACK回来就可以向右滑动。本例中，开始接收端空着AB，只有CD，此时不能滑动；之后接收到EF和H，直接向右滑动2位，不必等G到位。
3. 窗口大小不能大于序号空间大小的一半。目的是为了不让两个窗口出现交迭，比如总大小为7，窗口大小都为4，接收窗口应当滑动4，但只剩3个序号，导致两个窗口交迭。
4. 有一种情况没出现：发送方发ABCD，接收方都收到然后向右滑动，但回复的ACK包全丢了。发送方未收到任何ACK， timeout后会重发ABCD，此时的接收方按累计确认的原则，收到ABCD后只会重发D的ACK，发送方收到后向右滑动。



**tcp拥堵控制;**

当网络出现拥堵时2，部分数据将会丢失，此时发送方等待确认超时，会继续重新发送，从而到资质网络拥堵程度更高。

因此当网络出现拥堵时，应当控制发送方的速率。从而改善拥堵，

这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![img](https://camo.githubusercontent.com/97f4e3721a0e315511164d0faa6423cb8072d589/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35316532656439352d363562382d346165392d386166332d3635363032643435326132352e6a7067)

tcp主要通过四种算法来控制拥堵。

慢开始、拥塞避免、快重传、快恢复。



**拥堵窗口：**

tcp对拥堵的控制是通过拥堵窗口来实现的。

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口



拥堵窗口控制原理：

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

![image-20200331190223012](https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200331190226.png)

  1. **慢开始与拥塞避免**

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

  2. **快重传与快恢复**

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![image-20200331190237493](https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200331190249.png)

---



# 应用层

应用主要是通过各种协议，使得各种应用能够通过互联网完成通信。设计的技术和内容更加细化。同时随着技术的发展，应用层的传输协议也在不停的更新。这些知识，需要单独的进行学习记录。

**应用层主要包括：**

域名系统

文件传送协议

动态主机配置协议

远程登录协议

电子邮件协议：

* smtp
* pop3
* imap

常用端口

web页面请求过程