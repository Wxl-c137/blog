<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wxl-c137.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":"ture","scrollpercent":"ture"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Wxl&#39;s Study logs">
<meta property="og:url" content="https://wxl-c137.github.io/index.html">
<meta property="og:site_name" content="Wxl&#39;s Study logs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wxl-c137">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wxl-c137.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wxl's Study logs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wxl's Study logs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wxl-c137.github.io/posts/undefined.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wxl-c137">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wxl's Study logs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/undefined.html" class="post-title-link" itemprop="url">HTTPS原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-04 13:38:15 / 修改时间：13:39:00" itemprop="dateCreated datePublished" datetime="2020-04-04T13:38:15+08:00">2020-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p>https主要解决了web的信息安全问题。 因为http1.1中通信才用明文传输，很容易被截获利用，因此将重要信息进行加密传输避免的信息泄露。</p>
<hr>
<h2 id="常用的加密方法"><a href="#常用的加密方法" class="headerlink" title="常用的加密方法"></a>常用的加密方法</h2><h4 id="对称加密："><a href="#对称加密：" class="headerlink" title="对称加密："></a>对称加密：</h4><p>加密和机密使用的秘钥是一样的，通信双方使用的加密方法也是一样的，因此被称为对称加密。</p>
<p>​    <strong>优点：运算速度快</strong></p>
<p>​    <strong>缺点：因为加密需要使用同一秘钥，就必须将密匙发送给另一方。秘钥在传输过程中可能被截获，所以不安全</strong></p>
<p><img src="https://camo.githubusercontent.com/c95f015d173dd0dd54208f377c5ee9ba9e0d735f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37666666613462382d623336642d343731662d616430632d6138386565373633626237362e706e67" alt="img"></p>
<h4 id="非对称加密："><a href="#非对称加密：" class="headerlink" title="非对称加密："></a>非对称加密：</h4><p>加密和解密有不同的密匙，加密使用公钥，解密使用私钥，不需要传递私钥就可以完成加密传输。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<p>​    <strong>优点：可以更加安全的将公开秘钥传输给通信发送方</strong></p>
<p>​    <strong>缺点：非对称加密的算法相对复杂，运算速度不及对称加密</strong></p>
<p><img src="https://camo.githubusercontent.com/fe1d080a765b2285e0f91d882716c447ebf425f5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33396363623239392d656539392d346464312d623862342d3266396563393439356362342e706e67" alt="img"></p>
<hr>
<h2 id="‘中间人’攻击"><a href="#‘中间人’攻击" class="headerlink" title="‘中间人’攻击"></a>‘中间人’攻击</h2><p>非对称加密看似安全，但是黑客还是可以在传输中截获信息，冒充用户与服务端通信，再冒充服务端用用户通信，这样就能截获服务端和用户端的公钥进行解密了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/264052-c17453a8455daf75.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/882/format/webp" alt="img"></p>
<hr>
<h2 id="CA认证"><a href="#CA认证" class="headerlink" title="CA认证"></a>CA认证</h2><p>中间人攻击的主要问题在于用户没办法认证服务端的身份。</p>
<h3 id="CA认证是如何保证服务器的真实身份的？"><a href="#CA认证是如何保证服务器的真实身份的？" class="headerlink" title="CA认证是如何保证服务器的真实身份的？"></a>CA认证是如何保证服务器的真实身份的？</h3><p><strong>1，保证证书的真实性</strong></p>
<p><strong>申请证书</strong>：需要被验证的一端（通常是服务器），生成一份能够证明自己身份的证。<strong>这张证书必须是由权威CA机构颁发的，且尚在有效期内；或者是一张信任的私人证书</strong>。</p>
<p>服务器向CA机构提交自己的<strong>信息</strong>（如域名）和<strong>公钥</strong>（用户自己生成的非对称加密公钥，用于TLS握手阶段和另一端协商密钥用），CA机构生成数字证书，如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-a07b55499fd8867d5be415ecc77001a0_720w.jpg" alt="img"></p>
<p><strong>验证证书：</strong></p>
<p>收到对端发过来的证书，执行证书申请的“逆过程”即可，总结如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-074ad85981131fca65cf2d03ac292700_720w.jpg" alt="img"></p>
<p><img src="https://camo.githubusercontent.com/2901ef0e326dd93db4f6a815395fab9ff13225b2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f323031372d30362d31312d63612e706e67" alt="img"></p>
<p><strong>2.如何防止证书被篡改</strong></p>
<ul>
<li><p>在传输之前先对证书进行hash运算。黑客无法逆向运算得到证书原信息。</p>
</li>
<li><p>将CA证书放置一份在本地环境中，本地证书不会再网络上传输，也就不会被篡改。</p>
</li>
<li><p>将本地证书的hash运算结果与服务器发来的数据进行比对，结果一直则证明服务器的证书是真实的。</p>
</li>
</ul>
<h2 id="hash算法："><a href="#hash算法：" class="headerlink" title="hash算法："></a>hash算法：</h2><p><strong>安全散列算法</strong>（英语：Secure Hash Algorithm，缩写为SHA），是一个<a href="https://baike.baidu.com/item/密码散列函数" target="_blank" rel="noopener">密码散列函数</a>家族，是<a href="https://baike.baidu.com/item/FIPS" target="_blank" rel="noopener">FIPS</a>所认证的安全<a href="https://baike.baidu.com/item/散列算法" target="_blank" rel="noopener">散列算法</a>。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。</p>
<p>hash算法的特点是  无法通过秘钥反推明文。</p>
<hr>
<h2 id="SSL和TLS协议"><a href="#SSL和TLS协议" class="headerlink" title="SSL和TLS协议"></a>SSL和TLS协议</h2><p>虽然保证了证书无法被篡改，但是还是有被监听的风险，因此https使用了TLS协议进行传输。</p>
<h4 id="SSL-Secure-Socket-Layer-安全套接层"><a href="#SSL-Secure-Socket-Layer-安全套接层" class="headerlink" title="SSL(Secure Socket Layer 安全套接层)"></a>SSL(Secure Socket Layer 安全套接层)</h4><p>基于HTTPS下的一个协议加密层，最初是由网景公司（Netscape）研发，后被IETF（The Internet Engineering Task Force - 互联网工程任务组）标准化后写入（RFCRequest For Comments 请求注释），RFC里包含了很多互</p>
<h4 id="TLS-Transport-Layer-Security-安全传输层协议"><a href="#TLS-Transport-Layer-Security-安全传输层协议" class="headerlink" title="TLS(Transport Layer Security 安全传输层协议)"></a>TLS(Transport Layer Security 安全传输层协议)</h4><p>TLS就是SSL的新版本3.1，并同时发布“RFC2246-TLS加密协议详解”，如果想更深层次的了解TLS的工作原理可以去RFC的官方网站：<a href="http://www.rfc-editor.org，搜索RFC2246即可找到RFC文档！" target="_blank" rel="noopener">www.rfc-editor.org，搜索RFC2246即可找到RFC文档！</a></p>
<h3 id="TLS传输过程"><a href="#TLS传输过程" class="headerlink" title="TLS传输过程"></a>TLS传输过程</h3><ol>
<li>客户单发起请求。发送支持ssl版本、非对称加密算法、随机数1</li>
<li>服务端 回复确定ssl版本、对称加密算法、随机数2、ca证书</li>
<li>客户端认证ca证书，认证成功后，返回随机数3、hash（随机数1、随机数2）</li>
<li>服务端认证hash（随机数1、随机数2），使用随机数123+算法生成  对称加密秘钥</li>
<li>生成hash（前三步数据），发送给客户端</li>
<li>客户端认证hash（前三步数据），同样用随机数123+算法生成  对称加密秘钥。</li>
<li>自此服务器和客户端都获得了对称加密的秘钥，接下来使用对称加密进行传输。</li>
</ol>
<p><img src="C:%5CUsers%5Clulu%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200326204634865.png" alt="image-20200326204634865"></p>
<hr>
<h2 id="https安全验证过程"><a href="#https安全验证过程" class="headerlink" title="https安全验证过程"></a>https安全验证过程</h2><p>HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li>
</ul>
<p><img src="https://camo.githubusercontent.com/370d97acbc36633fdd170957bbdcf8f8c91230ff/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f486f772d48545450532d576f726b732e706e67" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wxl-c137.github.io/posts/4a17b156.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wxl-c137">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wxl's Study logs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/4a17b156.html" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-03 01:57:28" itemprop="dateCreated datePublished" datetime="2020-04-03T01:57:28+08:00">2020-04-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment<img src="https://raw.githubusercontent.com/Wxl-c137/Image-Hosting-/master/img/blender-infographic-2500-free.png" alt="blender-infographic-2500-free"></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wxl-c137.github.io/posts/44b77262.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wxl-c137">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wxl's Study logs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/44b77262.html" class="post-title-link" itemprop="url">计算机网络模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-31 18:55:09" itemprop="dateCreated datePublished" datetime="2020-03-31T18:55:09+08:00">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-03 01:57:28" itemprop="dateModified" datetime="2020-04-03T01:57:28+08:00">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>技术的迭代离不开实际应用。计算机科学也是如此。这个思想在我学习计算机组成和计算机网络时给我了很大的启发。  在学习时，不妨从实际应用出发。从 ‘’提出问题→技术解决问题→发现新问题→使用新技术‘’ 的思想来学习。</p>
<p>每一种技术都是为了解决问题而诞生的，当理解了这些技术是如何结局问题后，就会对技术有更加深刻的理解。</p>
<hr>
<h1 id="计算机网络模型"><a href="#计算机网络模型" class="headerlink" title="计算机网络模型"></a>计算机网络模型</h1><p>现代计算机网络模型大概分为三种，主要的差异在于传输层之后的细化。当到达传输层后及计算机之间的通信已经建立了有效的连接，之后的细分主要是具体应用和进程之间的协调。理解了物理层，数据链路层，网络层，传输层后就能够对整个计算机模型有宏观的认识。</p>
<p><strong>计算机网络三种模型：</strong></p>
<p><img src="https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200331185924.png" alt="image-20200331185916221"></p>
<ul>
<li>OSI分层      （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>
<li>TCP/IP分层（4层）：网络接口层、              网际层、运输层、                            应用层。</li>
<li>五层协议     （5层）：物理层、数据链路层、网络层、运输层、                            应用层。</li>
</ul>
<hr>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>将终端（计算机）组成网络的最基础方式就是用线缆连接各个终端。通过电信号完成终端之间的通信。</p>
<p><strong>连接方式</strong>： hub集线器。将终端两两连接的方式显然不可行，使用hub（集线器设备）将终端连接到一个端点，节省线材，容易实现。</p>
<p><strong>传递方式</strong>：为了确保每个终端都能通信。由hub同时向所有连接的设备广播带有标识的数据包，设备接收对应的数据。</p>
<p><strong>CMSA/CD协议</strong>：载波监听链路数据，确认有人在发送数据后，才开始发送数据，主要功能是解决数据冲突。</p>
<p><strong>数据包</strong>：高低电平数据信息+设备标识。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>数据（广播）同时发送给所有设备，带宽利用率低。</li>
<li>链路上同时只能有一台设备发送数据。</li>
<li>随着网络规模扩大，发送信号需要等待很长时间。</li>
</ul>
<p><strong>示例图</strong>：</p>
<p><img src="https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200330195445.png" alt="image-20200330195443040"></p>
<hr>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>为了解决物理层带宽利用率低的问题，在网络中添加了交换机。能够保存每个mac终端的地址，定向发送数据。同时使用双工网线，可以同时发送和接收数据。</p>
<p><strong>连接方式</strong>：交换机（switch）</p>
<p><strong>传递方式</strong>：交换机与hub相似，都是作为集线器。但是交换机会记录端口和设备mac地址的对应关系。通过线路至准确的放数据，而不是广播。</p>
<p><strong>数据包</strong>：包含数头和数部分。数据头记录了源地址和目的地址（mac地址）。</p>
<p><strong>mac地址</strong>：网络设备的全球唯一标识，是在设备出厂时就已经写死的。有6段，每段8个bit，是一个48位的标识。</p>
<p><strong>地址表</strong>：交换机会将端口和设备的mac地址对应关系记录在地址表中，当两台设备发生通信时，就可以找到对应的端口进行通信了。</p>
<p><strong>地址表的记录</strong>：当有新的设备接入交换机时，会遍历所有的接口，直到找到对应的端口，然后储存在地址标准中，下一次发送就可以直接找到对应端口了。</p>
<p><strong>桥接</strong>：多台交换机可以进行桥接，当一台交换机连接了另一台交换机后，会记录连接的端口和交换机的mac地址。</p>
<p>需要进行通信时，先传递数据到设备所在的交换机，再有交换机的地址表找到对对应的端口进行数据传输。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>通过地址表直接进行设备间的通信传输，不需要广播，提高了带宽利用率。</li>
<li>全双工,交换机网络内，设备的连接使用的是网线，含有8跟导线，可以做到同时收发信息。</li>
<li>可以进行桥接，组成小型网络，利用率很高</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>地址表能够保存的数据有限，一般一个地址表只能保存几千条，设备数量增多时利用率下降。</li>
</ul>
<p>示例图：</p>
<p><img src="https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200330195509.png" alt="image-20200330195507598"></p>
<hr>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>交换机虽然能够桥接，但是在大型网络中还是无法胜任。因此使用路由器将一个个小型网络连接在一起，当两个小型网络间需要通信时，通过ip地址来连接。这样就组成了现在的互联网。</p>
<p><strong>连接方式</strong>：网关（路由器）</p>
<p><strong>ip地址</strong>：记录设备在网络中的位置。当设备接入网络时会分配给ip地址。这个ip地址是暂时的，当设备更换时会被重新分配。*    ip地址是不能通信的，是一个抽象的地址。</p>
<p><strong>路由表</strong>：路由表会记录不同网络间ip对应的mac地址。</p>
<p><strong>arp协议</strong>：根据ip地址查询mac地址。在网络中广播，寻问目的ip地址，目的ip地址收到后会回复自己的ip地址和mac地址。</p>
<p><strong>数据包</strong>：数据头部分包含源地址的ip和目的地址的ip。</p>
<p><strong>传递方式</strong>：网关负责连接由交换机组成的不同的网络，当两台通信设备在不同的网络中时，会通过路由器在两个网络间传递数据。</p>
<p>​    当不同网络下的设备需要通信时：</p>
<ol>
<li><p>数据传递过程中源地址ip和目的地址ip不变。</p>
</li>
<li><p>因为数据传递只能通过mac地址进行，所以会逐步传输到链路上的各个网卡的mac地址，最终传到目的mac地址。</p>
</li>
<li><p>通过arp协议或传输过程中的各个mac地址。</p>
</li>
</ol>
<hr>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><a href="https://baike.baidu.com/item/网络层" target="_blank" rel="noopener">网络层</a>只是根据<a href="https://baike.baidu.com/item/网络地址" target="_blank" rel="noopener">网络地址</a>将源结点发出的<a href="https://baike.baidu.com/item/数据包" target="_blank" rel="noopener">数据包</a>传送到<a href="https://baike.baidu.com/item/目的" target="_blank" rel="noopener">目的</a>结点，而传输层则负责将数据可靠地传送到相应的端口。</p>
<ul>
<li>分组：接收方的传输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</li>
<li>复用：发送方不同的应用进程都可以使用同一个传输层协议传输数据。</li>
</ul>
<p><strong>进程通信的问题，为什么不能直接从ip连接到进程：</strong></p>
<ul>
<li>计算机中的进程使用进程标识来标志的，但是不同系统的进程标识方法不同。</li>
<li>进程的创建和撤销往往是动态的，有时候可能会更换进程但是不需要更换所接受的数据。</li>
<li>有时还需要目的主机提供的功能来识别重点，但是不需要知道实现这个功能的进程。</li>
</ul>
<p><strong>端口</strong>：IP地址只能标识到某台主机，但是数据最终要交付的是主机中的某个进程；一个主机中会有许多的进程，那么如何确定这个数据是要交付给哪个进程呢？此时就需要用到端口号。</p>
<p>于是在运输层使用协议端口号（protocolpport number），或者通常称为端口（port）。</p>
<p>端口使用一个16位的端口号进行标志。端口号只有本地意义，即端口号只是标识了本机中的各个进程。</p>
<p><strong>端口的分类：</strong></p>
<ul>
<li>端口号的范围是从1～65535，一般分为3类端口：熟知端口号，登记端口号，客户端口号或短暂端口号。</li>
<li>熟知端口号，数值一般为0~1023，每个端口号应用于特定熟知的应用协议。</li>
<li>登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在IANA(The Internet Assigned NumbersAuthority，互联网数字分配机构)登记，以防止重复。</li>
<li>客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li>
</ul>
<p><strong>套接字（socket）</strong></p>
<p>tcp协议中将连接作为基本的单位，每一条tcp连接两个端，都是由  主机ip+进程端口拼接而成，称作套接字。</p>
<p>套接字（socker）= ip地址：端口号</p>
<p>tcp连接== {socket1, socket2} = {(IP1: port1), (IP2: port2)}</p>
<p><strong>udp协议：</strong></p>
<ul>
<li>UDP是一种无连接，不可靠的协议。</li>
<li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li>
<li>此外，传输途中出现丢包，UDP 也不负责重发。甚至当包的到达顺序出现乱序时也没有纠正的功能。</li>
<li>UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。</li>
</ul>
<p>udp的头部：</p>
<p><img src="https://img-blog.csdnimg.cn/20181127124245824.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Njg0NTA0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20181127124512100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Njg0NTA0,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="tcp协议：tcp协议详细"><a href="#tcp协议：tcp协议详细" class="headerlink" title="tcp协议：tcp协议详细"></a><strong>tcp协议：</strong>tcp协议详细</h3><p><strong>三次握手：</strong></p>
<p>三次握手解决了tcp连接的建立问题。</p>
<p>通过三次握手建立连接：假设 A 为客户端，B 为服务器端。</p>
<ul>
<li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
</li>
<li><p>第一次握手`：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
</li>
<li><p>第二次握手`：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
</li>
<li><p>第三次握手`：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
</li>
</ul>
<blockquote>
<p>第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200331190007.png" alt="image-20200331190005051"></p>
<p><strong>四次挥手：</strong></p>
<p>因为tcp连接是全双工的，所以发送和接收的端口都要单独关闭，四次挥手保证的了关闭连接的在正确性，保证了连接关闭时不会丢失数据。</p>
<ul>
<li>TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。</li>
<li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器关闭客户端的连接，发送一个FIN给客户端。</li>
<li>客户段发回ACK报文确认，并将确认序号设置为收到序号加1。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200331190033.png" alt="image-20200331190026589"></p>
<p><strong>数据重传：</strong></p>
<p><strong>滑动窗口：</strong></p>
<p>滑动窗口是为了解决发送发送端和接收端对数据包的处理速度不同欧诺个，如何让双方达成一致。</p>
<p>TCP是双工的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方都各自维护一个<code>发送窗口</code>和一个<code>接收窗口</code>。各自的<code>接收窗口</code>大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的<code>发送窗口</code>则要求取决于对端通告的<code>接收窗口</code>，要求相同。</p>
<p><strong>TCP连接是通过数据包和ACK实现的，我们作为第三者可以看到双方发包的过程，但接受者在收到之前不知道发送方发的是什么，同样的，发送方在收到ACK前也不知道对方是否成功接收。</strong></p>
<ol>
<li>发送方没有收到接收方发回的ACK，就不能向右滑动。假设发送方向接收方发了ABCD就滑动，只要对方没收到A，就不能滑动，那么就会出现二者不同步的局面。</li>
<li>滑动窗口提高了信道利用率，TCP是发送报文段为单位的，假如每发一个报文就要等ACK，那么对于大数据包，等待时间就太长了。只要发送的报文在滑动窗口里面，不用等每个ACK回来就可以向右滑动。本例中，开始接收端空着AB，只有CD，此时不能滑动；之后接收到EF和H，直接向右滑动2位，不必等G到位。</li>
<li>窗口大小不能大于序号空间大小的一半。目的是为了不让两个窗口出现交迭，比如总大小为7，窗口大小都为4，接收窗口应当滑动4，但只剩3个序号，导致两个窗口交迭。</li>
<li>有一种情况没出现：发送方发ABCD，接收方都收到然后向右滑动，但回复的ACK包全丢了。发送方未收到任何ACK， timeout后会重发ABCD，此时的接收方按累计确认的原则，收到ABCD后只会重发D的ACK，发送方收到后向右滑动。</li>
</ol>
<p><strong>tcp拥堵控制;</strong></p>
<p>当网络出现拥堵时2，部分数据将会丢失，此时发送方等待确认超时，会继续重新发送，从而到资质网络拥堵程度更高。</p>
<p>因此当网络出现拥堵时，应当控制发送方的速率。从而改善拥堵，</p>
<p>这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p><img src="https://camo.githubusercontent.com/97f4e3721a0e315511164d0faa6423cb8072d589/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35316532656439352d363562382d346165392d386166332d3635363032643435326132352e6a7067" alt="img"></p>
<p>tcp主要通过四种算法来控制拥堵。</p>
<p>慢开始、拥塞避免、快重传、快恢复。</p>
<p><strong>拥堵窗口：</strong></p>
<p>tcp对拥堵的控制是通过拥堵窗口来实现的。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口</p>
<p>拥堵窗口控制原理：</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200331190226.png" alt="image-20200331190223012"></p>
<ol>
<li><strong>慢开始与拥塞避免</strong></li>
</ol>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<ol start="2">
<li><strong>快重传与快恢复</strong></li>
</ol>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<p><img src="https://raw.githubusercontent.com/Wxl-c137/Image-Hosting/master/img/20200331190249.png" alt="image-20200331190237493"></p>
<hr>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用主要是通过各种协议，使得各种应用能够通过互联网完成通信。设计的技术和内容更加细化。同时随着技术的发展，应用层的传输协议也在不停的更新。这些知识，需要单独的进行学习记录。</p>
<p><strong>应用层主要包括：</strong></p>
<p>域名系统</p>
<p>文件传送协议</p>
<p>动态主机配置协议</p>
<p>远程登录协议</p>
<p>电子邮件协议：</p>
<ul>
<li>smtp</li>
<li>pop3</li>
<li>imap</li>
</ul>
<p>常用端口</p>
<p>web页面请求过程</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wxl-c137.github.io/posts/465252c3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wxl-c137">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wxl's Study logs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/465252c3.html" class="post-title-link" itemprop="url">http发展史0.9~3.0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-30 17:55:09" itemprop="dateCreated datePublished" datetime="2020-03-30T17:55:09+08:00">2020-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-03 01:57:28" itemprop="dateModified" datetime="2020-04-03T01:57:28+08:00">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="http发展史"><a href="#http发展史" class="headerlink" title="http发展史"></a>http发展史</h1><h2 id="http0-9"><a href="#http0-9" class="headerlink" title="http0.9"></a>http0.9</h2><p>1991年</p>
<p>只有一个get命令：用于从服务器获取数据</p>
<p>没有header等数据描述信息</p>
<p>使用tcp协议进行通信，完成请求后会关闭连接</p>
<hr>
<h2 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h2><p>1996年</p>
<p>规定了header。</p>
<p>增加了status code</p>
<p>支持多字符集、多部分发送、权限、缓存</p>
<p>增加了post请求方法</p>
<h3 id="存在的问题问题："><a href="#存在的问题问题：" class="headerlink" title="存在的问题问题："></a>存在的问题问题：</h3><ul>
<li>连接无法复用</li>
</ul>
<p>每一个连接都会重新发起一次通信请求，这样就是频繁的请求tcp连接（进行三次握手和四次挥手），加上tcp的慢启动机制，使得网络利用率很低。</p>
<ul>
<li>head of line blocking(holb)</li>
</ul>
<p>TCP队头阻塞：tcp协议为了保证传输的可靠性。当部分数据分节丢失时，会将后续分解一直保存直到地狱会部分的数据被重传，才继续进行后续的传输。</p>
<p>有些情况下会因为一个数据的丢失让整个页面无法加载。</p>
<hr>
<h2 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h2><p>1997年</p>
<p>为了解决1.0中的问题http1.1中添加了永久连接和线管模式</p>
<h3 id="永久连接"><a href="#永久连接" class="headerlink" title="永久连接"></a>永久连接</h3><p>为了避免频繁的建立tcp连接，http1.1在请求头里面添加了 connection，默认属性是keep-alive。建立连接后连接会保持一段时间，期间如果再有需要发往服务器的请求就继续使用这个连接。避免了频繁的建立连接，提高了传输效率。</p>
<p>也可以同时向一个服务器请求多个连接，一般向同一个域名的连接为6个。</p>
<h3 id="相对http1-0d区别："><a href="#相对http1-0d区别：" class="headerlink" title="相对http1.0d区别："></a>相对http1.0d区别：</h3><ul>
<li>缓存处理</li>
<li>带宽优化及网络连接的使用</li>
<li>错误通知的管理</li>
<li>消息在网络中的发送</li>
<li>互联网地址的维护</li>
<li>安全性及完整性</li>
</ul>
<h3 id="常用的请求方式"><a href="#常用的请求方式" class="headerlink" title="常用的请求方式"></a>常用的请求方式</h3><ul>
<li>GET     请求获取Request-URI所标识的资源</li>
<li>POST    在Request-URI所标识的资源后附加新的数据</li>
<li>HEAD    请求获取由Request-URI所标识的资源的响应消息报头</li>
<li>PUT     请求服务器存储一个资源，并用Request-URI作为其标识</li>
<li>DELETE  请求服务器删除Request-URI所标识的资源</li>
<li>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断</li>
<li>CONNECT 保留将来使用</li>
<li>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</li>
<li><em>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。*</em>GET是用于获取数据的，POST一般用于将数据发给服务器之用**。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 请求</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line"></span><br><span class="line">Host:xxx.xxxx.com</span><br><span class="line"></span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.0.10) Gecko/2016042316 Firefox/3.0.10</span><br><span class="line"></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line"></span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line"></span><br><span class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line"></span><br><span class="line">Keep-Alive: 300</span><br><span class="line"></span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">If-Modified-Since: Mon, 25 May 2016 03:19:18 GMT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//响应</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">Cache-Control: private, max-age=30</span><br><span class="line"></span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line"></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line"></span><br><span class="line">Expires: Mon, 25 May 2016 03:20:33 GMT</span><br><span class="line"></span><br><span class="line">Last-Modified: Mon, 25 May 2016 03:20:03 GMT</span><br><span class="line"></span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line"></span><br><span class="line">Server: Microsoft-IIS/7.0</span><br><span class="line"></span><br><span class="line">X-AspNet-Version: 2.0.50727</span><br><span class="line"></span><br><span class="line">X-Powered-By: ASP.NET</span><br><span class="line"></span><br><span class="line">Date: Mon, 25 May 2016 03:20:02 GMT</span><br><span class="line"></span><br><span class="line">Content-Length: 12173</span><br><span class="line"></span><br><span class="line">消息体的内容（略）</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/Wxl-c137/Image-Hosting/blob/master/img/20200330182404.png?raw=true" alt="image20200330181234604"></p>
<h3 id="HTTP-1-1状态代码及其含义"><a href="#HTTP-1-1状态代码及其含义" class="headerlink" title="HTTP 1.1状态代码及其含义"></a>HTTP 1.1状态代码及其含义</h3><p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p>
<p>1xx：指示信息–表示请求已接收，继续处理</p>
<p>2xx：成功–表示请求已被成功接收、理解、接受</p>
<p>3xx：重定向–要完成请求必须进行更进一步的操作</p>
<p>4xx：客户端错误–请求有语法错误或请求无法实现</p>
<p>5xx：服务器端错误–服务器未能实现合法的请求</p>
<h3 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h3><p>hppt1.1仍然存在一些问题，这些问题在http2.0中有了更好的解决办法</p>
<ul>
<li><p>使用明文传输，没有压缩。</p>
</li>
<li><p>传输问题。</p>
</li>
<li><p>header太长了</p>
</li>
<li><p>server端  无法进行主动push</p>
<hr>
</li>
</ul>
<h2 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h2><p>2015年提出</p>
<h3 id="多路复用-Multiplexing"><a href="#多路复用-Multiplexing" class="headerlink" title="多路复用 (Multiplexing)"></a><strong>多路复用 (Multiplexing)</strong></h3><p>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一</p>
<p>而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的数据帧，这些数据帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。</p>
<h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><p>HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。</p>
<p>在http1.1中因为tcp的慢启动机制，让很多突发性和短时性的连接变得很低效。http2.0中通过一个tcp连接中的多路传输，解决了这个问题。</p>
<p>并且随着tcp连接的减少，也减少了服务器的连接压力，内存压力，连接的吞吐量更大了。网络拥堵的现象也得到了改善。</p>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>HTTP/1.1并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生， SPDY 使用的是通用的DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法。</p>
<h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。Server Push 让 HTTP1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p>
<h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>因为http的传输是明文，所以很容易被截获利用。即使使用加密通信也会存在‘’中间人‘’问题。因此https通过第三方机构的证书认证方式，使得通信前可以认证服务器的身份。  使得通信更加安全。</p>
<p>http是的具体的加密原可以看这边文章：%link</p>
<hr>
<h2 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h2><p>2019年</p>
<h3 id="从tcp改为udp"><a href="#从tcp改为udp" class="headerlink" title="从tcp改为udp"></a>从tcp改为udp</h3><h3 id="机制一：自定义连接机制"><a href="#机制一：自定义连接机制" class="headerlink" title="机制一：自定义连接机制"></a>机制一：自定义连接机制</h3><p>一条tcp连接是由四元组标识的，分别是源ip、源端口、目的端口，一旦一个元素发生变化时，就会断开重连，重新连接。在次进行三次握手，导致一定的延时</p>
<p>在TCP是没有办法的，但是基于UDP，就可以在QUIC自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个64<br>位的随机数作为ID来标识，而且UDP是无连接的，所以当ip或者端口变化的时候，只要ID不变，就不需要重新建立连接</p>
<h3 id="机制二：自定义重传机制"><a href="#机制二：自定义重传机制" class="headerlink" title="机制二：自定义重传机制"></a>机制二：自定义重传机制</h3><p>tcp为了保证可靠性，通过使用序号和应答机制，来解决顺序问题和丢包问题</p>
<p>任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包，通过自适应重传算法（通过采样往返时间RTT不断调整）</p>
<p>但是，在TCP里面超时的采样存在不准确的问题。例如发送一个包，序号100，发现没有返回，于是在发送一个100，过一阵返回ACK101.客户端收到了，但是往返的时间是多少，没法计算。是ACK到达的时候减去第一还是第二。</p>
<p>QUIC也有个序列号，是递增的，任何宇哥序列号的包只发送一次，下次就要加1，那样就计算可以准确了</p>
<p>但是有一个问题，就是怎么知道包100和包101发送的是同样的内容呢？quic定义了一个offset概念。QUIC既然是面向连接的，也就像TCP一样，是一个数据流，发送的数据在这个数据流里面有个偏移量offset，可以通过offset查看数据发送到了那里，这样只有这个offset的包没有来，就要重发。如果来了，按照offset拼接，还是能够拼成一个流。</p>
<h3 id="机制三：-无阻塞的多路复用"><a href="#机制三：-无阻塞的多路复用" class="headerlink" title="机制三： 无阻塞的多路复用"></a>机制三： 无阻塞的多路复用</h3><p>有了自定义的连接和重传机制，就可以解决上面HTTP2.0的多路复用问题</p>
<p>同HTTP2.0一样，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但是，QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。这样，假如stream2丢了一个UDP包，后面跟着stream3的一个UDP包，虽然stream2的那个包需要重新传，但是stream3的包无需等待，就可以发给用户。</p>
<h3 id="机制四：自定义流量控制"><a href="#机制四：自定义流量控制" class="headerlink" title="机制四：自定义流量控制"></a>机制四：自定义流量控制</h3><p>TCP的流量控制是通过滑动窗口协议。QUIC的流量控制也是通过window_update，来告诉对端它可以接受的字节数。但是QUIC的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个steam控制窗口。</p>
<p>在TCP协议中，接收端的窗口的起始点是下一个要接收并且ACK的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为TCP的ACK机制是基于序列号的累计应答，一旦ACK了一个序列号，就说明前面的都到了，所以是要前面的没到，后面的到了也不能ACK,就会导致后面的到了，也有可能超时重传，浪费带宽</p>
<p>QUIC的ACK是基于offset的，每个offset的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空档会等待到来或者重发，而窗口的起始位置为当前收到的最大offset，从这个offset到当前的stream所能容纳的最大缓存，是真正的窗口的大小，显然，那样更加准确。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wxl-c137</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wxl-c137</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/unitychan.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body>
</html>
